# 리액티브 API 개발하기

## 스프링 WebFlux 사용하기

스프링 MVC 같은 서블릿 기반의 웹 프레임워크는 스레드 풀에서 작업 스레드를 가져와서 해당 요청을 처리하고

작업이 종료될 때까지 요청 스레드가 블로킹된다.

오늘날에는 다양한 사물인터넷(클라이언트) 에서 웹 API 를 요청하고 데이터를 교환한다. 웹 애플리케이션을 

사용하는 클라이언트 수가 증가함에 따라 웹 어플리케이션의 확장성이 중요해졌다!

비동기 웹 프레임워크는 더 적은 스레드로 (CPU 코어당 하나의 스레드) 더 높은 확장성을 가져갈 수 있다.

이벤트루핑 기법을 이용해서 하나의 스레드가 더 많은 요청을 처리할 수 있다.

### 스프링 WebFlux 개요
```
MVC 와 WebFlux 는 같은 애노테이션을 공유한다.
웹 플럭스는 내장 서버로 톰캣 대신 비동기 이벤트 중심 서버인 Netty 를 사용한다.

스프링 MVC 도 리액티브 타입을 반환할 수 있다 단지 MVC 는 다중 스레드에 의존하는
서블릿 기반 웹 프레임워크라면 

WebFlux 는 요청이 이벤트 루프로 처리되는 진정한 리액티브 웹 프레임워크이다.
```

### 리액티브 컨트롤러 작성하기

DesignTacoController 참고

```
리액티브 컨트롤러는 리액티브 엔드-to-엔드 스택의 제일 끝에 위치하게 된다.

클라이언트 -> 컨트롤러 -> 서비스(선택적) -> 리포지토리
        리포지토리 -> 서비스(선택적) -> 컨트롤러(리액티브 타입 반환)
        
리액티브 컨트롤러는 MVC 컨트롤러와 크게 다르지 않고 반환 타입만 다르다.

Flux<Taco> 와 같은 리액티브 타입을 받을 때는 구독자(클라이언트) 추가 메서드 .subscribe() 를 
호출할 필요가 없다. 프레임워크가 대신 호출해준다! 

단일 값을 반환할 때는 Mono 타입을 사용하면된다!
```
```
* RxJava 타입 사용하기

웹 플럭스를 사용할 때는 Flux,Mono 같은 리액티브 타입이 자연스러운 선택 이지만,
Observable 이나 Single 같은 RxJava 타입을 사용할 수도 있다. 380p
```
```
* 리액티브하게 입력 처리하기 postTaco 메서드 참고 

MVC RestController 를 사용해서 데이터를 인자로 받으면 @RequestBody 애노테이션을 이용해서 
객체로 만들어야 한다. 그리고 데이터를 사용할 서비스나 리포지토리를 호출한다.

이렇게되면 총 두 번의 스레드 블로킹이 발생한다 처음 인자를 받을 때, 애플리케이션 로직을 호출할 때 

리액티브하게 입력처리를 하고싶다면 Publisher 인터페이스를 구현한 타입(Mono, Flux) 을 인자로 받는다
그러면 요청 메서드 몸체의 서비스나 리포지토리는 Taco 객체가 분석되는 것을 기다리지 않고 즉시 호출된다.

리포지토리도 리액티브로 만들었으므로 Mono 타입을 받고 즉시 Flux 로 반환된다. 마지막으로 next 를 호출해서
Flux 를 Mono<Taco> 값으로 반환하도록 하면 Mono 타입으로 값을 반환할 수 있다.

Flux: 0, 1 또는 다수의 데이터를 갖는 파이프라인을 가진다
Mono: 하나의 데이터 항목만 갖는 리액티브 타입
```
### 함수형 요청 핸들러 정의하기 



